{"ast":null,"code":"var parseKeys = require('parse-asn1');\n\nvar randomBytes = require('randombytes');\n\nvar createHash = require('create-hash');\n\nvar mgf = require('./mgf');\n\nvar xor = require('./xor');\n\nvar bn = require('bn.js');\n\nvar withPublic = require('./withPublic');\n\nvar crt = require('browserify-rsa');\n\nvar constants = {\n  RSA_PKCS1_OAEP_PADDING: 4,\n  RSA_PKCS1_PADDIN: 1,\n  RSA_NO_PADDING: 3\n};\n\nmodule.exports = function publicEncrypt(public_key, msg, reverse) {\n  var padding;\n\n  if (public_key.padding) {\n    padding = public_key.padding;\n  } else if (reverse) {\n    padding = 1;\n  } else {\n    padding = 4;\n  }\n\n  var key = parseKeys(public_key);\n  var paddedMsg;\n\n  if (padding === 4) {\n    paddedMsg = oaep(key, msg);\n  } else if (padding === 1) {\n    paddedMsg = pkcs1(key, msg, reverse);\n  } else if (padding === 3) {\n    paddedMsg = new bn(msg);\n\n    if (paddedMsg.cmp(key.modulus) >= 0) {\n      throw new Error('data too long for modulus');\n    }\n  } else {\n    throw new Error('unknown padding');\n  }\n\n  if (reverse) {\n    return crt(paddedMsg, key);\n  } else {\n    return withPublic(paddedMsg, key);\n  }\n};\n\nfunction oaep(key, msg) {\n  var k = key.modulus.byteLength();\n  var mLen = msg.length;\n  var iHash = createHash('sha1').update(new Buffer('')).digest();\n  var hLen = iHash.length;\n  var hLen2 = 2 * hLen;\n\n  if (mLen > k - hLen2 - 2) {\n    throw new Error('message too long');\n  }\n\n  var ps = new Buffer(k - mLen - hLen2 - 2);\n  ps.fill(0);\n  var dblen = k - hLen - 1;\n  var seed = randomBytes(hLen);\n  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));\n  var maskedSeed = xor(seed, mgf(maskedDb, hLen));\n  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));\n}\n\nfunction pkcs1(key, msg, reverse) {\n  var mLen = msg.length;\n  var k = key.modulus.byteLength();\n\n  if (mLen > k - 11) {\n    throw new Error('message too long');\n  }\n\n  var ps;\n\n  if (reverse) {\n    ps = new Buffer(k - mLen - 3);\n    ps.fill(0xff);\n  } else {\n    ps = nonZero(k - mLen - 3);\n  }\n\n  return new bn(Buffer.concat([new Buffer([0, reverse ? 1 : 2]), ps, new Buffer([0]), msg], k));\n}\n\nfunction nonZero(len, crypto) {\n  var out = new Buffer(len);\n  var i = 0;\n  var cache = randomBytes(len * 2);\n  var cur = 0;\n  var num;\n\n  while (i < len) {\n    if (cur === cache.length) {\n      cache = randomBytes(len * 2);\n      cur = 0;\n    }\n\n    num = cache[cur++];\n\n    if (num) {\n      out[i++] = num;\n    }\n  }\n\n  return out;\n}","map":{"version":3,"sources":["/home/pratik/Downloads/crowdfunder/node_modules/public-encrypt/publicEncrypt.js"],"names":["parseKeys","require","randomBytes","createHash","mgf","xor","bn","withPublic","crt","constants","RSA_PKCS1_OAEP_PADDING","RSA_PKCS1_PADDIN","RSA_NO_PADDING","module","exports","publicEncrypt","public_key","msg","reverse","padding","key","paddedMsg","oaep","pkcs1","cmp","modulus","Error","k","byteLength","mLen","length","iHash","update","Buffer","digest","hLen","hLen2","ps","fill","dblen","seed","maskedDb","concat","maskedSeed","nonZero","len","crypto","out","i","cache","cur","num"],"mappings":"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","sourcesContent":["var parseKeys = require('parse-asn1');\nvar randomBytes = require('randombytes');\nvar createHash = require('create-hash');\nvar mgf = require('./mgf');\nvar xor = require('./xor');\nvar bn = require('bn.js');\nvar withPublic = require('./withPublic');\nvar crt = require('browserify-rsa');\n\nvar constants = {\n  RSA_PKCS1_OAEP_PADDING: 4,\n  RSA_PKCS1_PADDIN: 1,\n  RSA_NO_PADDING: 3\n};\n\nmodule.exports = function publicEncrypt(public_key, msg, reverse) {\n  var padding;\n  if (public_key.padding) {\n    padding = public_key.padding;\n  } else if (reverse) {\n    padding = 1;\n  } else {\n    padding = 4;\n  }\n  var key = parseKeys(public_key);\n  var paddedMsg;\n  if (padding === 4) {\n    paddedMsg = oaep(key, msg);\n  } else if (padding === 1) {\n    paddedMsg = pkcs1(key, msg, reverse);\n  } else if (padding === 3) {\n    paddedMsg = new bn(msg);\n    if (paddedMsg.cmp(key.modulus) >= 0) {\n      throw new Error('data too long for modulus');\n    }\n  } else {\n    throw new Error('unknown padding');\n  }\n  if (reverse) {\n    return crt(paddedMsg, key);\n  } else {\n    return withPublic(paddedMsg, key);\n  }\n};\n\nfunction oaep(key, msg){\n  var k = key.modulus.byteLength();\n  var mLen = msg.length;\n  var iHash = createHash('sha1').update(new Buffer('')).digest();\n  var hLen = iHash.length;\n  var hLen2 = 2 * hLen;\n  if (mLen > k - hLen2 - 2) {\n    throw new Error('message too long');\n  }\n  var ps = new Buffer(k - mLen - hLen2 - 2);\n  ps.fill(0);\n  var dblen = k - hLen - 1;\n  var seed = randomBytes(hLen);\n  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));\n  var maskedSeed = xor(seed, mgf(maskedDb, hLen));\n  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));\n}\nfunction pkcs1(key, msg, reverse){\n  var mLen = msg.length;\n  var k = key.modulus.byteLength();\n  if (mLen > k - 11) {\n    throw new Error('message too long');\n  }\n  var ps;\n  if (reverse) {\n    ps = new Buffer(k - mLen - 3);\n    ps.fill(0xff);\n  } else {\n    ps = nonZero(k - mLen - 3);\n  }\n  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));\n}\nfunction nonZero(len, crypto) {\n  var out = new Buffer(len);\n  var i = 0;\n  var cache = randomBytes(len*2);\n  var cur = 0;\n  var num;\n  while (i < len) {\n    if (cur === cache.length) {\n      cache = randomBytes(len*2);\n      cur = 0;\n    }\n    num = cache[cur++];\n    if (num) {\n      out[i++] = num;\n    }\n  }\n  return out;\n}"]},"metadata":{},"sourceType":"script"}